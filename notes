# STRINGS
# double backslash (\\) produces a single backslash
# backslash and b deletes the preceding letter
# \n adds new line
# Strings are iterable- character arrays
# Iterates starting at 0 or -1 from the rightmost letter, increases and decreases respectively
# slicing: [begin:end:step]
# a[1:4]: stop before 4
# a[-5,-2]: stop before -2
# a[2:6:2]: step size 2. stop before 6
# dont hop on opposite train
# reversing a string 
# extended slicing: omit beginning and end w [::-1]
# this way, max possible values of beginning and ending
# "adding" strings, len(str), a.upper() and a.lower(), casting: new_string = str(36)
# id() function- good way to measure if a variable is mutable or immutable
# NOTHING BUT SCRAP
# ids are not addresses
# they both refer to the same thing, but they aren't the same thing.
# immutable- once created, it cannot be modified. However, it can be reassigned
# assignment of an immutable variable creates a new memory address
# individually changing a part of a string address cannot happen
# YOU NEED MORE POWER
# when printing variables of many different type, it auto casts them to be strings'
# type casting: use curly brackets {}
# user input taken via input()
# .format takes the contents of the curly brackets and replaces them using the arguments


# LISTS
# List type in python stres an ordered list of variable sequence
# Varaibles can be of different type
# List can be an element of a different list
# List elements addressed using []
# Lists are mutable- can be modified
# clear() empties a lsit
# insert (position, element): adds a new element at position - later elements moved back by one
# pop(position): removes and retorns the element
# ex: source.pop(0) where source = notebook will return the first letter n
#extend(new_list): mege lissts
# similar operator: list + new list
# sort(): sorts list elements
# count(element): counts occurences of an element value in the list
# list type casting: list()
# string.join(): joining iterable elements in the input argument, concatenating them w string inb etween
# ,join(): merge list elements into a string
# .reverse()- reverses a list
# time.time()- begin and end clock time
# ticused to begin, toc used for end
# elapsed_time- toc-tic
# genesis time is 1970, Jan.1, 00:00:00
# time returns amount of seconds from 1970
# popping the first n numbers in a list requires you to perform pop(0) n times
# it takes the letter out, so the next letter becomes the index
# while modifying lists, the IDs remain the same, cuz it's mutable
# IS THIS WHAT I LOST TO?!


# python Memory
# For immutable integers of same values, small int values share memory/ID
# large integers have different ID
# same for strings
# all floats have different IDs - Python does not compare floating points

# conditions & loops
# while loop
# while condition is True, run the code, and retest the condition
# when condition is false, jump to after the loop
# variables determining the state of the loop are updated during the loop
# exiting a loop
# if condition: break
# break jumps out of the CURRENT code blcok where it is in
# for loop
# continue- skips rest of code and jumps back to beginning

# Functions

# built-in functions
# stand-alone functions include print, type, range, round, int
# methods in objects are list.reverse() and string.format()

# imported functions:
# math.floor(), math.ceil, math,.sqrt, etc.

# user-defined functions
# extend imported function list
# imported functions are user-defined functions created by other programmers

# adding a .__doc__ after the function prints any triple- dot (""") comments
# input values in a function call must match with its input argument definition
# provide default values using equal signs int he arguments 

# .sort() function is ascending normally
# must set reverse as True in the argument to be descending
# new_object = sorted(list/tuple/string) sorts lists

# tuples and dictionaries
# t = (value_1, value_2... etc)
# t = vaue_1, value)2, n
# r = tuple('abcde)
# tuple elements can be addressed like a list
# tuples are immutable. but their elements are mutable and can be changed
# we can use > to compare tuples according to ASCII code
# returns a boolean
# dictionaries
# every element is a (key, value) pair
# ex: D = {1: one, 2:two...}
# dictionary is a mutable type
# add/modify entry: dictionary[key] = value
# remove entry: del(dictionary[key])

# Set Operations
# Union- s|t or s.union(t)
# Intersection- s&t or s.intersection(t)
# Difference- s-t or s.difference(t)
# Exlcusive (XOR)- s^t, or s.symmetric_difference(t)
# s.issuperset(t)
# s.issubset(t)

# Class Methods
# Instance Methods - interact via self reference as the first argument
# Class Mehods- methods that interact with class attributes via @clasmethod declaration
# Statuc Methods- utility functions that do not interact with either instance or class attributes via @staticmethod declaration
# Class and static methods can be called by referencing class name
# inheritance: class(OtherClass)



# challenges 
# 1-3 challenge 1 sucks


# SMART goals are 
# remember what you learned in carattini's class
# specific, measurable, attainable, realistic, timely

